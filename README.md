# OpsCord - DevOps Intelligence Platform

OpsCord is a unified DevOps intelligence platform that aggregates events from your entire toolchain (GitHub, Jira, GitLab, Sentry, etc.) into a single, context-aware timeline. It leverages AI to provide actionable summaries, semantic linking between dispersed activities, and team-centric workflows.

![Status](https://img.shields.io/badge/Status-Beta-blue) ![License](https://img.shields.io/badge/License-MIT-green) ![Tech](https://img.shields.io/badge/Stack-Next.js%20%7C%20Supabase-black)

## üöÄ Key Features

OpsCord moves beyond simple activity feeds by adding a layer of intelligence and structure:

### Phase 1: Unified Timeline & Context

- **Centralized Feed**: Aggregates webhooks from GitHub, Jira, GitLab, Discord, and Slack.
- **Timeline Drawer**: Deep-dive into any event without leaving the dashboard. Use the "Context Graph" to see related PRs, Issues, and Deployments.

### Phase 2: Cross-Tool Linking (The Graph)

- **Semantic Linkification**: Automatically detects issue keys (e.g., `PROJ-123`) and repo references, turning them into navigable links.
- **Relationship Graph**: Visualizes "incoming" and "outgoing" connections (e.g., a Deployment linked to the Commit that triggered it).

### Phase 3: AI & Trust

- **AI Summaries**: "Daily Standup" and "Incident Review" cards generated by LLMs (mocked/integrated).
- **Attention Scoring**: Highlights critical events (failures, blockers) while dimming noise.
- **User Feedback**: RLHF-style thumbs up/down on insights to improve future summaries.

### Phase 4: Enterprise-Ready RBAC

- **Multi-Tenancy**: Built from the ground up for Organizations.
- **Granular Permissions**: Role-Based Access Control (RBAC) with roles like `Owner`, `Admin`, `Developer`, and `Viewer`.
- **Org Switcher**: Seamlessly toggle between different team contexts.

### Phase 5: Frictionless Onboarding

- **Setup Wizard**: Step-by-step flow to name your Org, invite members, and connect tools.
- **Invite System**: Secure, token-based email invitations.

### Phase 6: Audit & Security

- **Audit Logs**: Immutable log of critical actions (member changes, key rotations) visible to Admins.
- **Row-Level Security (RLS)**: Data isolation enforced at the database level.

### Phase 7: Scalability

- **Event Queue**: usage of `ingestion_queue` to buffer high-volume webhooks.
- **Caching**: Redis-style KV caching (`ai_cache`) for expensive LLM operations.
- **Quotas**: Soft limits on events and seats to prevent abuse.

### Phase 8: Adoption Experience

- **Product Tour**: Interactive overlay highlighting key UI features.
- **Quickstart Checklist**: Gamified widget to guide new admins through setup.

### Phase 9: Social Signals

- **Kudos**: Light-weight peer recognition (likes/hearts) on timeline items.
- **Sentiment Analysis**: Auto-tagging of activities as Positive/Negative/Neutral.

---

## üõ† Tech Stack

- **Frontend**: Next.js 14/15 (App Router), React, TypeScript, Tailwind CSS, Framer Motion.
- **Backend / DB**: Supabase (PostgreSQL), Edge Functions.
- **Auth**: Supabase Auth (SSR w/ Next.js Middleware).
- **AI**: OpenAI API (proxy via Edge Functions).
- **Styling**: Shadcn UI, Lucide Icons.

---

## üèó Architecture

### Data Model

- **Activities**: The core unit of data. Normalized schema with `jsonb` payloads for tool-specific details.
- **Event Links**: Many-to-Many graph connecting activities based on regex matches or explicit references.
- **Embeddings** (Optional): `pgvector` support for semantic search.

### Ingestion Pipeline

1.  **Webhook**: Tool sends JSON payload to `api/webhooks/[provider]`.
2.  **Queue**: Event pushed to `ingestion_queue` (Phase 7).
3.  **Worker**: Process calls `processQueueBatch`, normalizing data into `activities`.
4.  **Enrichment**: AI Service calculates sentiment and summary asynchronously.

---

## üèÅ Getting Started

### Prerequisites

- Node.js 18+
- Supabase Project (Free Tier works)

### Installation

1.  **Clone the repo**

    ```bash
    git clone https://github.com/your-org/opscord.git
    cd opscord
    ```

2.  **Install dependencies**

    ```bash
    npm install
    ```

3.  **Environment Setup**
    Create `.env.local`:

    ```env
    NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
    NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_key
    SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
    OPENAI_API_KEY=your_openai_key
    ```

4.  **Database Migration**
    Run the SQL scripts in `migrations/` against your Supabase SQL Editor in order:

    1.  `001_create_tables.sql`
    2.  `008_org_rbac.sql`
    3.  `009_audit_logs.sql`
    4.  `010_scalability.sql`
    5.  `011_social_features.sql`

5.  **Run Development Server**
    ```bash
    npm run dev
    ```
    Open [http://localhost:3000](http://localhost:3000).

---

## ü§ù Contributing

1.  Fork the project.
2.  Create your feature branch (`git checkout -b feature/AmazingFeature`).
3.  Commit your changes.
4.  Push to the branch.
5.  Open a Pull Request.

---

## üìÑ License

Distributed under the MIT License. See `LICENSE` for more information.
